<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Depth Handicap Match (No Draws)</title>
<style>
  :root {
    --bg: #0f1322;
    --panel: #171d31;
    --line: #2b3558;
    --text: #e7edff;
    --muted: #98a7d3;
    --good: #56e6ac;
    --bad: #ff7f7f;
    --warn: #ffd26d;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0;
    color: var(--text);
    background: radial-gradient(1200px 700px at 10% 0%, #1a2242 0%, var(--bg) 50%);
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  }
  .wrap { max-width: 1120px; margin: 24px auto; padding: 0 16px; }
  h1 { margin: 0 0 8px; font-size: 20px; color: var(--good); }
  .sub { font-size: 13px; color: var(--muted); margin-bottom: 14px; }
  .panel {
    background: color-mix(in srgb, var(--panel) 92%, black);
    border: 1px solid var(--line);
    border-radius: 12px;
    padding: 12px;
    margin-bottom: 12px;
  }
  .controls {
    display: grid;
    grid-template-columns: repeat(6, minmax(120px, 1fr));
    gap: 10px;
    align-items: end;
  }
  label { display: block; font-size: 12px; color: var(--muted); margin-bottom: 4px; }
  input {
    width: 100%;
    padding: 8px;
    border: 1px solid var(--line);
    border-radius: 8px;
    background: #11172b;
    color: var(--text);
    font: inherit;
  }
  .btns { display: flex; gap: 8px; flex-wrap: wrap; grid-column: span 2; }
  button {
    border: 1px solid var(--line);
    border-radius: 8px;
    padding: 9px 12px;
    color: var(--text);
    background: #16203d;
    cursor: pointer;
    font: inherit;
  }
  button.primary {
    background: linear-gradient(180deg, #1f2f60, #1a274f);
    border-color: #587ced;
  }
  button:disabled { opacity: 0.6; cursor: not-allowed; }
  .score {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 10px;
  }
  .card {
    border: 1px solid var(--line);
    border-radius: 10px;
    background: #10172f;
    padding: 10px;
  }
  .name { color: var(--muted); font-size: 12px; margin-bottom: 6px; }
  .val { font-size: 22px; font-weight: 700; color: var(--good); }
  #log {
    white-space: pre-wrap;
    max-height: 58vh;
    overflow: auto;
    background: #0d1328;
    border: 1px solid #223051;
    border-radius: 10px;
    padding: 10px;
    font-size: 12px;
    line-height: 1.35;
  }
  .ok { color: var(--good); }
  .bad { color: var(--bad); }
  .warn { color: var(--warn); }
  @media (max-width: 1000px) {
    .controls { grid-template-columns: repeat(2, minmax(120px, 1fr)); }
    .btns { grid-column: auto; }
    .score { grid-template-columns: 1fr; }
  }
</style>
</head>
<body>
  <div class="wrap">
    <h1>Depth Handicap Match: SF18 Compat ST vs Chess.com SF17 Lite ST</h1>
    <div class="sub">No draws mode: drawn endings are resolved by eval tiebreak. Openings are varied to avoid deterministic repetition.</div>

    <div class="panel">
      <div class="controls">
        <div>
          <label for="games">Games</label>
          <input id="games" type="number" value="20" min="2" max="400" step="2">
        </div>
        <div>
          <label for="baseDepth">Base Depth</label>
          <input id="baseDepth" type="number" value="16" min="4" max="60" step="1">
        </div>
        <div>
          <label for="oursOffset">Ours Depth Offset</label>
          <input id="oursOffset" type="number" value="-1" min="-10" max="10" step="1">
        </div>
        <div>
          <label for="ccOffset">Chess.com Depth Offset</label>
          <input id="ccOffset" type="number" value="1" min="-10" max="10" step="1">
        </div>
        <div>
          <label for="maxPlies">Max Plies Per Game</label>
          <input id="maxPlies" type="number" value="220" min="60" max="600" step="10">
        </div>
        <div class="btns">
          <button id="runBtn" class="primary">Run Match</button>
          <button id="stopBtn">Stop</button>
          <button id="clearBtn">Clear Log</button>
        </div>
      </div>
      <div id="status" class="sub" style="margin:10px 0 0;">Idle</div>
    </div>

    <div class="panel score">
      <div class="card">
        <div class="name">SF18 Compat ST (ours)</div>
        <div class="val" id="oursScore">-</div>
      </div>
      <div class="card">
        <div class="name">Chess.com SF17 Lite ST</div>
        <div class="val" id="ccScore">-</div>
      </div>
      <div class="card">
        <div class="name">Record (ours)</div>
        <div class="val" id="record">-</div>
      </div>
    </div>

    <div class="panel">
      <div id="log"></div>
    </div>
  </div>

<script>
const ENGINE_DEFS = {
  ours: { key: "ours", name: "SF18 Compat ST (ours)", file: "../engines/compat/sf18-compat-st.js" },
  cc: { key: "cc", name: "Chess.com SF17 Lite ST", file: "../engines/reference/stockfish-17-lite-single.js" }
};

const OPENINGS = [
  { name: "Start", fen: "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1" },
  { name: "Open Center", fen: "rnbqkb1r/pppp1ppp/5n2/4p3/2B1P3/5N2/PPPP1PPP/RNBQK2R w KQkq - 2 3" },
  { name: "Middlegame A", fen: "rnbq1rk1/pp2bppp/2pp1n2/8/2PNP3/2N1B3/PP3PPP/R2QKB1R w KQ - 0 8" },
  { name: "Middlegame B", fen: "r1bq1rk1/pppn1ppp/3bpn2/3p4/3P4/2NBPN2/PPQ2PPP/R1B2RK1 w - - 0 8" },
  { name: "Middlegame C", fen: "r4rk1/pp2qppp/2npbn2/2p5/2P1P3/2N1BN2/PPQ2PPP/R4RK1 w - - 0 12" },
  { name: "Kingside Pressure", fen: "r1bq1rk1/pp3pbp/2np1np1/2p1p3/2P1P3/2N2NP1/PP2PPBP/R1BQ1RK1 w - - 0 8" }
];

let stopRequested = false;
let runInProgress = false;
let liveWorkers = [];

const logEl = document.getElementById("log");
const statusEl = document.getElementById("status");
const oursScoreEl = document.getElementById("oursScore");
const ccScoreEl = document.getElementById("ccScore");
const recordEl = document.getElementById("record");
const runBtn = document.getElementById("runBtn");

function log(msg, cls) {
  const d = document.createElement("div");
  d.textContent = msg;
  if (cls) d.className = cls;
  logEl.appendChild(d);
  logEl.scrollTop = logEl.scrollHeight;
}

function setStatus(msg) { statusEl.textContent = msg; }

function cleanupWorkers() {
  for (const w of liveWorkers) {
    try { w.terminate(); } catch {}
  }
  liveWorkers = [];
}

class WorkerEngine {
  constructor(def) {
    this.def = def;
    this.worker = null;
    this.lines = [];
    this.pending = [];
  }

  _emit(line) {
    const idx = this.lines.push(line) - 1;
    const keep = [];
    for (const p of this.pending) {
      if (idx >= p.sinceIdx && p.pred(line)) {
        clearTimeout(p.timer);
        p.resolve(line);
      } else {
        keep.push(p);
      }
    }
    this.pending = keep;
  }

  waitFor(pred, timeoutMs = 30000, sinceIdx = 0) {
    for (let i = Math.max(0, sinceIdx); i < this.lines.length; i += 1) {
      if (pred(this.lines[i])) return Promise.resolve(this.lines[i]);
    }
    return new Promise((resolve, reject) => {
      const pending = {
        sinceIdx,
        pred,
        resolve,
        timer: setTimeout(() => {
          this.pending = this.pending.filter((x) => x !== pending);
          reject(new Error(this.def.name + " timeout"));
        }, timeoutMs)
      };
      this.pending.push(pending);
    });
  }

  send(cmd) { this.worker.postMessage(cmd); }

  async init() {
    this.worker = new Worker(this.def.file);
    liveWorkers.push(this.worker);

    this.worker.onmessage = (e) => {
      const raw = e && typeof e.data !== "undefined" ? e.data : "";
      const text = typeof raw === "string"
        ? raw
        : raw && typeof raw === "object" && typeof raw.text === "string"
          ? raw.text
          : raw && typeof raw === "object" && typeof raw.line === "string"
            ? raw.line
            : raw && typeof raw === "object" && typeof raw.message === "string"
              ? raw.message
              : raw && typeof raw === "object" && typeof raw.output === "string"
                ? raw.output
                : String(raw);
      for (const line of text.split(/\r?\n/)) {
        const clean = line.trim();
        if (clean) this._emit(clean);
      }
    };
    this.worker.onerror = (e) => this._emit("ERROR: " + (e.message || "worker error"));

    this.send("uci");
    await this.waitFor((l) => l === "uciok", 60000);
    this.send("setoption name Threads value 1");
    this.send("setoption name Hash value 16");
    this.send("isready");
    await this.waitFor((l) => l === "readyok", 30000);
    this.lines = [];
  }

  async newGame() {
    this.send("ucinewgame");
    this.send("isready");
    await this.waitFor((l) => l === "readyok", 20000);
    this.lines = [];
  }

  parseBestInfo(startIdx) {
    let best = null;
    for (let i = startIdx; i < this.lines.length; i += 1) {
      const line = this.lines[i];
      if (!line.startsWith("info ")) continue;
      const depth = Number((line.match(/\bdepth\s+(\d+)/) || [])[1]);
      const nodes = Number((line.match(/\bnodes\s+(\d+)/) || [])[1]);
      const nps = Number((line.match(/\bnps\s+(\d+)/) || [])[1]);
      const sm = line.match(/\bscore\s+(cp|mate)\s+(-?\d+)/);
      const scoreType = sm ? sm[1] : null;
      const score = sm ? Number(sm[2]) : null;
      if (!Number.isFinite(depth) || !Number.isFinite(nodes)) continue;
      if (!best || depth > best.depth || (depth === best.depth && nodes > best.nodes)) {
        best = { depth, nodes, nps: Number.isFinite(nps) ? nps : 0, scoreType, score, raw: line };
      }
    }
    return best;
  }

  async searchDepth(moves, depth, openingFen) {
    const startIdx = this.lines.length;
    if (moves.length) this.send("position fen " + openingFen + " moves " + moves.join(" "));
    else this.send("position fen " + openingFen);
    this.send("go depth " + depth);

    let bestLine;
    try {
      bestLine = await this.waitFor((l) => l.startsWith("bestmove "), 30000, startIdx);
    } catch (e) {
      this.send("stop");
      try {
        bestLine = await this.waitFor((l) => l.startsWith("bestmove "), 6000, startIdx);
      } catch {
        const tail = this.lines.slice(Math.max(0, this.lines.length - 12)).join(" | ");
        throw new Error(this.def.name + " timeout (tail: " + (tail || "no output") + ")");
      }
    }

    const bestMove = (bestLine.split(/\s+/)[1] || "").trim();
    const readyIdx = this.lines.length;
    this.send("isready");
    await this.waitFor((l) => l === "readyok", 10000, readyIdx);
    return { bestMove, info: this.parseBestInfo(startIdx), bestLine };
  }

  close() {
    try { this.send("quit"); } catch {}
    try { this.worker.terminate(); } catch {}
  }
}

function pointsFromResult(result, oursIsWhite) {
  if (result === "1-0") return oursIsWhite ? 1 : 0;
  if (result === "0-1") return oursIsWhite ? 0 : 1;
  return 0.5;
}

function resultFromWhiteCp(whiteCp, gameNo) {
  if (whiteCp > 8) return "1-0";
  if (whiteCp < -8) return "0-1";
  // Exact/near-zero tie: alternate winner by game number to avoid color bias.
  return gameNo % 2 === 1 ? "1-0" : "0-1";
}

function adjudicateNoMove(sideToMove, info, lastWhiteCp, gameNo) {
  if (info && info.scoreType === "mate") {
    if (info.score > 0) return sideToMove === "white" ? "1-0" : "0-1";
    return sideToMove === "white" ? "0-1" : "1-0";
  }
  if (info && info.scoreType === "cp" && Number.isFinite(info.score)) {
    const whiteCp = sideToMove === "white" ? info.score : -info.score;
    return resultFromWhiteCp(whiteCp, gameNo);
  }
  if (Number.isFinite(lastWhiteCp)) return resultFromWhiteCp(lastWhiteCp, gameNo);
  return resultFromWhiteCp(0, gameNo);
}

async function playOneGame(engines, gameNo, oursIsWhite, oursDepth, ccDepth, maxPlies, opening) {
  await engines.ours.newGame();
  await engines.cc.newGame();

  const openingFen = opening.fen;
  const openingTurn = (openingFen.split(/\s+/)[1] || "w");
  const moves = [];
  let result = null;
  let reason = "";
  let lowEvalStreak = 0;
  let lastWhiteCp = 0;

  for (let ply = 0; ply < maxPlies; ply += 1) {
    if (stopRequested) throw new Error("Stopped");

    const whiteToMove = openingTurn === "w" ? (ply % 2 === 0) : (ply % 2 === 1);
    const sideToMove = whiteToMove ? "white" : "black";
    const oursTurn = (oursIsWhite && whiteToMove) || (!oursIsWhite && !whiteToMove);
    const actor = oursTurn ? engines.ours : engines.cc;
    const actorName = oursTurn ? "ours" : "chesscom";
    const d = oursTurn ? oursDepth : ccDepth;

    setStatus("Game " + gameNo + " ply " + (ply + 1) + " (" + actorName + " d" + d + ")");

    let out;
    try {
      out = await actor.searchDepth(moves, d, openingFen);
    } catch (e) {
      result = sideToMove === "white" ? "0-1" : "1-0";
      reason = actorName + " timeout/engine error";
      log("G" + gameNo + " " + (ply + 1) + ". " + actorName + " failed: " + (e && e.message ? e.message : String(e)), "bad");
      break;
    }

    const infoTxt = out.info ? ("d" + out.info.depth + " n=" + out.info.nodes) : "no-info";
    log("G" + gameNo + " " + (ply + 1) + ". " + actorName + " -> " + out.bestMove + " (" + infoTxt + ")");

    if (!out.bestMove || out.bestMove === "(none)") {
      result = adjudicateNoMove(sideToMove, out.info, lastWhiteCp, gameNo);
      reason = "no legal move/draw -> eval tiebreak";
      break;
    }

    moves.push(out.bestMove);

    if (out.info && out.info.scoreType === "cp" && Number.isFinite(out.info.score)) {
      lastWhiteCp = sideToMove === "white" ? out.info.score : -out.info.score;
      if (Math.abs(out.info.score) <= 8) lowEvalStreak += 1;
      else lowEvalStreak = 0;
    } else if (out.info && out.info.scoreType === "mate" && Number.isFinite(out.info.score)) {
      const mateCp = out.info.score > 0 ? 30000 : -30000;
      lastWhiteCp = sideToMove === "white" ? mateCp : -mateCp;
      lowEvalStreak = 0;
    } else {
      lowEvalStreak = 0;
    }

    // Reduce endless shuffles while keeping fairness: eval-based decisive tiebreak.
    if (ply >= 180 && lowEvalStreak >= 60) {
      result = resultFromWhiteCp(lastWhiteCp, gameNo);
      reason = "stable equal eval -> tiebreak";
      break;
    }
  }

  if (!result) {
    result = resultFromWhiteCp(lastWhiteCp, gameNo);
    reason = "max plies reached -> tiebreak";
  }
  return { result, plies: moves.length, reason };
}

async function runMatch() {
  if (runInProgress) {
    log("A match is already running.", "warn");
    return;
  }

  runInProgress = true;
  runBtn.disabled = true;
  stopRequested = false;
  cleanupWorkers();
  logEl.textContent = "";
  oursScoreEl.textContent = "-";
  ccScoreEl.textContent = "-";
  recordEl.textContent = "-";

  const gamesReq = Math.max(2, Number(document.getElementById("games").value) || 20);
  const games = gamesReq % 2 === 0 ? gamesReq : gamesReq + 1;
  const baseDepth = Math.max(1, Number(document.getElementById("baseDepth").value) || 16);
  const oursDepth = Math.max(1, baseDepth + (Number(document.getElementById("oursOffset").value) || 0));
  const ccDepth = Math.max(1, baseDepth + (Number(document.getElementById("ccOffset").value) || 0));
  const maxPlies = Math.max(60, Number(document.getElementById("maxPlies").value) || 220);

  if (games !== gamesReq) {
    log("Games adjusted to even number: " + games, "warn");
  }

  log("=== Depth Handicap No-Draw Match ===", "ok");
  log("Games=" + games + " | baseDepth=" + baseDepth + " | oursDepth=" + oursDepth + " | chesscomDepth=" + ccDepth + " | maxPlies=" + maxPlies);
  log("Rule: no draws (eval-based tiebreak, alternating tie winner if exactly equal).");

  let engines = null;
  try {
    setStatus("Loading engines...");
    engines = {
      ours: new WorkerEngine(ENGINE_DEFS.ours),
      cc: new WorkerEngine(ENGINE_DEFS.cc)
    };

    await engines.ours.init();
    log("Loaded " + ENGINE_DEFS.ours.name, "ok");
    await engines.cc.init();
    log("Loaded " + ENGINE_DEFS.cc.name, "ok");

    let oursScore = 0;
    let ccScore = 0;
    let w = 0, l = 0;

    for (let g = 1; g <= games; g += 1) {
      if (stopRequested) throw new Error("Stopped");
      const oursIsWhite = g % 2 === 1;
      const opening = OPENINGS[Math.floor((g - 1) / 2) % OPENINGS.length];
      const label = oursIsWhite ? "ours=W" : "ours=B";
      log("");
      log("Game " + g + "/" + games + " (" + label + ", opening=" + opening.name + ")", "ok");
      const out = await playOneGame(engines, g, oursIsWhite, oursDepth, ccDepth, maxPlies, opening);
      const p = pointsFromResult(out.result, oursIsWhite);
      oursScore += p;
      ccScore += 1 - p;
      if (p === 1) w += 1;
      else l += 1;
      log("Result G" + g + ": " + out.result + " | plies=" + out.plies + " | " + out.reason, "warn");

      oursScoreEl.textContent = oursScore + " / " + g;
      ccScoreEl.textContent = ccScore + " / " + g;
      recordEl.textContent = "+" + w + " -" + l;
    }

    log("");
    log("=== Final Summary ===", "ok");
    log("Ours: " + oursScore + "/" + games);
    log("Chess.com: " + ccScore + "/" + games);
    log("Record (ours): +" + w + " -" + l);
    setStatus("Done");
  } finally {
    if (engines) {
      try { engines.ours.close(); } catch {}
      try { engines.cc.close(); } catch {}
    }
    cleanupWorkers();
    runInProgress = false;
    runBtn.disabled = false;
  }
}

document.getElementById("runBtn").addEventListener("click", async () => {
  try {
    await runMatch();
  } catch (err) {
    log("ERROR: " + (err && err.message ? err.message : String(err)), "bad");
    setStatus(stopRequested ? "Stopped" : "Failed");
    cleanupWorkers();
    runInProgress = false;
    runBtn.disabled = false;
  }
});

document.getElementById("stopBtn").addEventListener("click", () => {
  if (!runInProgress) return;
  stopRequested = true;
  setStatus("Stopping...");
  cleanupWorkers();
});

document.getElementById("clearBtn").addEventListener("click", () => {
  logEl.textContent = "";
  setStatus("Idle");
});
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>2-Game Match: SF18 Compat ST vs Chess.com Lite ST</title>
<style>
  :root {
    --bg: #0f1322;
    --panel: #171d31;
    --line: #2a3455;
    --text: #e8edff;
    --muted: #9ba8d1;
    --good: #53e6a8;
    --bad: #ff7b7b;
    --warn: #ffd36b;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0;
    background: radial-gradient(1200px 700px at 10% 0%, #1a2242 0%, var(--bg) 50%);
    color: var(--text);
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  }
  .wrap { max-width: 1100px; margin: 24px auto; padding: 0 16px; }
  h1 { margin: 0 0 8px; color: var(--good); font-size: 20px; }
  .sub { color: var(--muted); font-size: 13px; margin-bottom: 14px; }
  .panel {
    background: color-mix(in srgb, var(--panel) 92%, black);
    border: 1px solid var(--line);
    border-radius: 12px;
    padding: 12px;
    margin-bottom: 12px;
  }
  .controls {
    display: grid;
    grid-template-columns: 180px 180px 1fr;
    gap: 10px;
    align-items: end;
  }
  label { display: block; color: var(--muted); font-size: 12px; margin-bottom: 4px; }
  input {
    width: 100%;
    padding: 8px;
    border: 1px solid var(--line);
    border-radius: 8px;
    background: #11172b;
    color: var(--text);
    font: inherit;
  }
  .btns { display: flex; gap: 8px; flex-wrap: wrap; }
  button {
    border: 1px solid var(--line);
    background: #16203d;
    color: var(--text);
    font: inherit;
    border-radius: 8px;
    padding: 9px 12px;
    cursor: pointer;
  }
  button.primary {
    background: linear-gradient(180deg, #1e2f60, #1a274f);
    border-color: #5578e8;
  }
  .score {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 10px;
  }
  .card {
    border: 1px solid var(--line);
    border-radius: 10px;
    background: #10172f;
    padding: 10px;
  }
  .name { color: var(--muted); font-size: 12px; margin-bottom: 6px; }
  .val { font-size: 21px; font-weight: 700; color: var(--good); }
  #log {
    white-space: pre-wrap;
    max-height: 58vh;
    overflow: auto;
    background: #0d1328;
    border: 1px solid #222d4e;
    border-radius: 10px;
    padding: 10px;
    font-size: 12px;
    line-height: 1.35;
  }
  .ok { color: var(--good); }
  .bad { color: var(--bad); }
  .warn { color: var(--warn); }
  @media (max-width: 820px) {
    .controls { grid-template-columns: 1fr 1fr; }
    .score { grid-template-columns: 1fr; }
  }
</style>
</head>
<body>
  <div class="wrap">
    <h1>2-Game Match: SF18 Compat ST vs Chess.com SF17 Lite ST</h1>
    <div class="sub">Two games, same movetime for both engines. Game 1: ours as White. Game 2: ours as Black.</div>

    <div class="panel">
      <div class="controls">
        <div>
          <label for="movetime">Movetime Per Move (ms)</label>
          <input id="movetime" type="number" value="1200" min="10" step="10">
        </div>
        <div>
          <label for="maxPlies">Max Plies Per Game</label>
          <input id="maxPlies" type="number" value="220" min="60" max="500" step="10">
        </div>
        <div class="btns">
          <button id="runBtn" class="primary">Run 2 Games</button>
          <button id="stopBtn">Stop</button>
          <button id="clearBtn">Clear Log</button>
        </div>
      </div>
      <div id="status" class="sub" style="margin:10px 0 0;">Idle</div>
    </div>

    <div class="panel score">
      <div class="card">
        <div class="name">SF18 Compat ST (ours)</div>
        <div class="val" id="oursScore">-</div>
      </div>
      <div class="card">
        <div class="name">Chess.com SF17 Lite ST</div>
        <div class="val" id="ccScore">-</div>
      </div>
      <div class="card">
        <div class="name">Match Result</div>
        <div class="val" id="matchResult">-</div>
      </div>
    </div>

    <div class="panel"><div id="log"></div></div>
  </div>

<script>
const ENGINE_DEFS = {
  ours: { key: "ours", name: "SF18 Compat ST (ours)", file: "../engines/compat/sf18-compat-st.js" },
  cc: { key: "cc", name: "Chess.com SF17 Lite ST", file: "../engines/reference/stockfish-17-lite-single.js" }
};

let stopRequested = false;
let liveWorkers = [];
let runInProgress = false;

const logEl = document.getElementById("log");
const statusEl = document.getElementById("status");
const oursScoreEl = document.getElementById("oursScore");
const ccScoreEl = document.getElementById("ccScore");
const matchResultEl = document.getElementById("matchResult");

function log(msg, cls) {
  const d = document.createElement("div");
  d.textContent = msg;
  if (cls) d.className = cls;
  logEl.appendChild(d);
  logEl.scrollTop = logEl.scrollHeight;
}

function setStatus(msg) {
  statusEl.textContent = msg;
}

function formatScore(v) {
  if (v === 1 || v === 0) return String(v);
  if (v === 0.5) return "0.5";
  if (Number.isFinite(v) && Math.round(v * 2) === v * 2) return String(v);
  return v.toFixed(2);
}

class WorkerEngine {
  constructor(def) {
    this.def = def;
    this.worker = null;
    this.lines = [];
    this.pending = [];
  }

  _emit(line) {
    const idx = this.lines.push(line) - 1;
    const survivors = [];
    for (const p of this.pending) {
      if (idx >= p.sinceIdx && p.pred(line)) {
        clearTimeout(p.timer);
        p.resolve(line);
      } else {
        survivors.push(p);
      }
    }
    this.pending = survivors;
  }

  waitFor(pred, timeoutMs = 30000, sinceIdx = 0) {
    for (let i = Math.max(0, sinceIdx); i < this.lines.length; i += 1) {
      if (pred(this.lines[i])) return Promise.resolve(this.lines[i]);
    }
    return new Promise((resolve, reject) => {
      const pending = {
        sinceIdx,
        pred,
        resolve,
        timer: setTimeout(() => {
          this.pending = this.pending.filter((x) => x !== pending);
          reject(new Error(this.def.name + " timeout"));
        }, timeoutMs)
      };
      this.pending.push(pending);
    });
  }

  send(cmd) {
    this.worker.postMessage(cmd);
  }

  async init() {
    this.worker = new Worker(this.def.file);
    liveWorkers.push(this.worker);
    this.worker.onmessage = (e) => {
      const raw = e && typeof e.data !== "undefined" ? e.data : "";
      const text = typeof raw === "string"
        ? raw
        : raw && typeof raw === "object" && typeof raw.text === "string"
          ? raw.text
          : raw && typeof raw === "object" && typeof raw.line === "string"
            ? raw.line
            : raw && typeof raw === "object" && typeof raw.message === "string"
              ? raw.message
              : raw && typeof raw === "object" && typeof raw.output === "string"
                ? raw.output
                : String(raw);
      for (const line of text.split(/\r?\n/)) {
        const clean = line.trim();
        if (clean) this._emit(clean);
      }
    };
    this.worker.onerror = (e) => this._emit("ERROR: " + (e.message || "worker error"));

    this.send("uci");
    await this.waitFor((l) => l === "uciok", 60000);
    this.send("setoption name Threads value 1");
    this.send("setoption name Hash value 16");
    this.send("isready");
    await this.waitFor((l) => l === "readyok", 30000);
    this.lines = [];
  }

  async newGame() {
    this.send("ucinewgame");
    this.send("isready");
    await this.waitFor((l) => l === "readyok", 30000);
    this.lines = [];
  }

  parseBestInfo(fromIdx) {
    let best = null;
    for (let i = fromIdx; i < this.lines.length; i += 1) {
      const line = this.lines[i];
      if (!line.startsWith("info ")) continue;
      const depth = Number((line.match(/\bdepth\s+(\d+)/) || [])[1]);
      const nodes = Number((line.match(/\bnodes\s+(\d+)/) || [])[1]);
      const nps = Number((line.match(/\bnps\s+(\d+)/) || [])[1]);
      const sm = line.match(/\bscore\s+(cp|mate)\s+(-?\d+)/);
      const scoreType = sm ? sm[1] : null;
      const score = sm ? Number(sm[2]) : null;
      if (!Number.isFinite(depth) || !Number.isFinite(nodes)) continue;
      if (!best || depth > best.depth || (depth === best.depth && nodes > best.nodes)) {
        best = {
          depth,
          nodes,
          nps: Number.isFinite(nps) ? nps : 0,
          scoreType,
          score,
          raw: line
        };
      }
    }
    return best;
  }

  async searchFromMoves(moves, movetimeMs) {
    const startIdx = this.lines.length;
    if (moves.length) this.send("position startpos moves " + moves.join(" "));
    else this.send("position startpos");
    this.send("go movetime " + movetimeMs);
    let bestLine = null;
    const searchTimeout = Math.max(12000, movetimeMs * 8 + 4000);
    try {
      bestLine = await this.waitFor(
        (l) => l.startsWith("bestmove "),
        searchTimeout,
        startIdx
      );
    } catch (e) {
      // Recovery path for occasional worker stalls: force stop and wait once more.
      this.send("stop");
      try {
        bestLine = await this.waitFor(
          (l) => l.startsWith("bestmove "),
          5000,
          startIdx
        );
      } catch {
        const tail = this.lines.slice(Math.max(0, this.lines.length - 12)).join(" | ");
        throw new Error(this.def.name + " timeout (tail: " + (tail || "no output") + ")");
      }
    }
    const bestMove = (bestLine.split(/\s+/)[1] || "").trim();
    const readyIdx = this.lines.length;
    this.send("isready");
    await this.waitFor((l) => l === "readyok", 10000, readyIdx);
    return {
      bestMove,
      info: this.parseBestInfo(startIdx),
      bestLine
    };
  }

  close() {
    try { this.send("quit"); } catch {}
    try { this.worker.terminate(); } catch {}
  }
}

function cleanupWorkers() {
  for (const w of liveWorkers) {
    try { w.terminate(); } catch {}
  }
  liveWorkers = [];
}

function pointsFromResult(result, oursIsWhite) {
  if (result === "1-0") return oursIsWhite ? 1 : 0;
  if (result === "0-1") return oursIsWhite ? 0 : 1;
  return 0.5;
}

function sideToResult(winnerSide) {
  if (winnerSide === "white") return "1-0";
  if (winnerSide === "black") return "0-1";
  return "1/2-1/2";
}

function adjudicateNoMove(sideToMove, info) {
  if (info && info.scoreType === "mate") {
    // score <= 0 with no legal move normally means side to move is mated.
    if (info.score > 0) return sideToResult(sideToMove);
    return sideToResult(sideToMove === "white" ? "black" : "white");
  }
  if (info && info.scoreType === "cp" && Number.isFinite(info.score)) {
    if (Math.abs(info.score) <= 20) return "1/2-1/2";
    if (info.score > 0) return sideToResult(sideToMove);
    return sideToResult(sideToMove === "white" ? "black" : "white");
  }
  return "1/2-1/2";
}

async function playOneGame(engines, oursIsWhite, movetimeMs, maxPlies, gameNumber) {
  await engines.ours.newGame();
  await engines.cc.newGame();

  const moves = [];
  let lowEvalStreak = 0;
  let result = null;
  let reason = "";

  for (let ply = 0; ply < maxPlies; ply += 1) {
    if (stopRequested) throw new Error("Stopped");
    const whiteToMove = ply % 2 === 0;
    const sideToMove = whiteToMove ? "white" : "black";
    const oursTurn = (oursIsWhite && whiteToMove) || (!oursIsWhite && !whiteToMove);
    const actor = oursTurn ? engines.ours : engines.cc;
    const actorName = oursTurn ? "ours" : "chesscom";

    setStatus("Game " + gameNumber + " move " + (ply + 1) + " (" + actorName + " thinking)");
    let out;
    try {
      out = await actor.searchFromMoves(moves, movetimeMs);
    } catch (e) {
      const winner = sideToMove === "white" ? "black" : "white";
      result = sideToResult(winner);
      reason = actorName + " timeout/engine error";
      log("G" + gameNumber + " " + (ply + 1) + ". " + actorName + " failed: " + (e && e.message ? e.message : String(e)), "bad");
      break;
    }
    const infoTxt = out.info ? ("d" + out.info.depth + " n=" + out.info.nodes) : "no-info";
    log("G" + gameNumber + " " + (ply + 1) + ". " + actorName + " -> " + out.bestMove + " (" + infoTxt + ")");

    if (!out.bestMove || out.bestMove === "(none)") {
      result = adjudicateNoMove(sideToMove, out.info);
      reason = "no legal move";
      break;
    }

    moves.push(out.bestMove);

    if (out.info && out.info.scoreType === "cp" && Math.abs(out.info.score) <= 12) {
      lowEvalStreak += 1;
    } else {
      lowEvalStreak = 0;
    }
    // Keep adjudication conservative so we don't end balanced games too early.
    if (ply >= 180 && lowEvalStreak >= 80) {
      result = "1/2-1/2";
      reason = "low-eval draw adjudication";
      break;
    }
  }

  if (!result) {
    result = "1/2-1/2";
    reason = "max plies reached";
  }
  return { result, moves: moves.length, reason };
}

async function runTwoGames() {
  if (runInProgress) {
    log("A match is already running. Click Stop or wait for completion.", "warn");
    return;
  }
  runInProgress = true;
  document.getElementById("runBtn").disabled = true;
  stopRequested = false;
  cleanupWorkers();
  oursScoreEl.textContent = "-";
  ccScoreEl.textContent = "-";
  matchResultEl.textContent = "-";
  logEl.textContent = "";
  log("=== 2-Game Match Start ===", "ok");

  const movetime = Math.max(10, Number(document.getElementById("movetime").value) || 1200);
  const maxPlies = Math.max(60, Number(document.getElementById("maxPlies").value) || 220);
  log("Movetime: " + movetime + "ms | Max plies: " + maxPlies);
  log("Game 1: ours White, chesscom Black");
  log("Game 2: chesscom White, ours Black");

  let engines = null;
  try {
    setStatus("Loading engines...");
    engines = {
      ours: new WorkerEngine(ENGINE_DEFS.ours),
      cc: new WorkerEngine(ENGINE_DEFS.cc)
    };

    await engines.ours.init();
    log("Loaded " + ENGINE_DEFS.ours.name, "ok");
    await engines.cc.init();
    log("Loaded " + ENGINE_DEFS.cc.name, "ok");

    let oursScore = 0;
    let ccScore = 0;
    let oursWins = 0;
    let ccWins = 0;
    let draws = 0;

    const game1 = await playOneGame(engines, true, movetime, maxPlies, 1);
    let pts = pointsFromResult(game1.result, true);
    oursScore += pts;
    ccScore += 1 - pts;
    if (game1.result === "1-0") oursWins += 1;
    else if (game1.result === "0-1") ccWins += 1;
    else draws += 1;
    log("Game 1 result: " + game1.result + " | plies=" + game1.moves + " | " + game1.reason, "warn");

    const game2 = await playOneGame(engines, false, movetime, maxPlies, 2);
    pts = pointsFromResult(game2.result, false);
    oursScore += pts;
    ccScore += 1 - pts;
    if (game2.result === "0-1") oursWins += 1;
    else if (game2.result === "1-0") ccWins += 1;
    else draws += 1;
    log("Game 2 result: " + game2.result + " | plies=" + game2.moves + " | " + game2.reason, "warn");

    oursScoreEl.textContent = formatScore(oursScore) + " / 2";
    ccScoreEl.textContent = formatScore(ccScore) + " / 2";
    if (oursScore > ccScore) {
      matchResultEl.textContent = "OURS WIN";
      matchResultEl.style.color = "var(--good)";
    } else if (oursScore < ccScore) {
      matchResultEl.textContent = "CHESS.COM WIN";
      matchResultEl.style.color = "var(--bad)";
    } else {
      matchResultEl.textContent = "DRAWN MATCH";
      matchResultEl.style.color = "var(--warn)";
    }

    log("");
    log("=== Match Summary ===", "ok");
    log("Ours: " + formatScore(oursScore) + "/2");
    log("Chess.com: " + formatScore(ccScore) + "/2");
    log("Record (ours): +" + oursWins + " =" + draws + " -" + ccWins);
    setStatus(stopRequested ? "Stopped" : "Done");
  } finally {
    if (engines) {
      try { engines.ours.close(); } catch {}
      try { engines.cc.close(); } catch {}
    }
    cleanupWorkers();
    runInProgress = false;
    document.getElementById("runBtn").disabled = false;
  }
}

document.getElementById("runBtn").addEventListener("click", async () => {
  try {
    await runTwoGames();
  } catch (err) {
    log("ERROR: " + (err && err.message ? err.message : String(err)), "bad");
    setStatus(stopRequested ? "Stopped" : "Failed");
    cleanupWorkers();
  }
});

document.getElementById("stopBtn").addEventListener("click", () => {
  if (!runInProgress) return;
  stopRequested = true;
  cleanupWorkers();
  setStatus("Stopping...");
});

document.getElementById("clearBtn").addEventListener("click", () => {
  logEl.textContent = "";
  setStatus("Idle");
});
</script>
</body>
</html>
